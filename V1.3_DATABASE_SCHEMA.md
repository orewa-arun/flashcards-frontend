# v1.3 PostgreSQL Database Schema

## Overview

The v1.3 implementation uses PostgreSQL with SQLAlchemy ORM for managing courses and lectures.

## Tables

### courses

Stores course metadata.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | INTEGER | PRIMARY KEY, AUTOINCREMENT | Auto-generated course ID |
| `course_code` | VARCHAR(255) | UNIQUE, NOT NULL, INDEX | User-provided course identifier (e.g., "MAPP_F_MKT404_EN_2025") |
| `course_name` | TEXT | NOT NULL | Full name of the course |
| `instructor` | TEXT | NULL | Instructor name |
| `additional_info` | TEXT | NULL | Additional course information |
| `reference_textbooks` | JSONB | DEFAULT [] | Array of textbook titles |
| `created_at` | TIMESTAMP WITH TIMEZONE | NOT NULL, DEFAULT NOW() | Creation timestamp |
| `updated_at` | TIMESTAMP WITH TIMEZONE | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Indexes**:
- Primary key on `id`
- Unique index on `course_code`

**Relationships**:
- One-to-many with `lectures` (cascade delete)

---

### lectures

Stores lecture PDFs and all generated content.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | INTEGER | PRIMARY KEY, AUTOINCREMENT | Auto-generated lecture ID |
| `course_code` | VARCHAR(255) | FOREIGN KEY, NOT NULL, INDEX | References `courses.course_code` |
| `lecture_title` | TEXT | NOT NULL | Title/filename of the lecture |
| `r2_pdf_path` | TEXT | NOT NULL | Path to PDF in Cloudflare R2 bucket |
| `structured_analysis` | JSONB | NULL | Generated structured analysis JSON |
| `flashcards` | JSONB | NULL | Generated flashcards JSON |
| `quizzes` | JSONB | NULL | Generated quizzes array: `[{"level": 1, "questions": [...]}, ...]` |
| `analysis_status` | VARCHAR(50) | NOT NULL, DEFAULT 'pending', INDEX | Status: pending/in_progress/completed/failed |
| `flashcard_status` | VARCHAR(50) | NOT NULL, DEFAULT 'pending', INDEX | Status: pending/in_progress/completed/failed |
| `quiz_status` | VARCHAR(50) | NOT NULL, DEFAULT 'pending', INDEX | Status: pending/in_progress/completed/failed |
| `qdrant_status` | VARCHAR(50) | NOT NULL, DEFAULT 'pending', INDEX | Status: pending/in_progress/completed/failed |
| `error_log` | JSONB | NULL | Error details by step (e.g., `{"analysis_error": {...}}`) |
| `created_at` | TIMESTAMP WITH TIMEZONE | NOT NULL, DEFAULT NOW() | Creation timestamp |
| `updated_at` | TIMESTAMP WITH TIMEZONE | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Indexes**:
- Primary key on `id`
- Foreign key index on `course_code`
- Index on `analysis_status`
- Index on `flashcard_status`
- Index on `quiz_status`
- Index on `qdrant_status`

**Relationships**:
- Many-to-one with `courses`

**Foreign Key Constraints**:
- `course_code` references `courses.course_code` ON DELETE CASCADE

---

## JSONB Column Structures

### structured_analysis

Example structure (implementation-specific):
```json
{
  "lecture_title": "Session 1 - The New Consumer",
  "model_used": "gemini-2.0-pro-exp",
  "generated_at": "2025-11-24T10:05:00Z",
  "sections": [
    {
      "title": "Introduction",
      "content": "...",
      "key_points": ["point1", "point2"]
    }
  ],
  "key_concepts": ["concept1", "concept2"],
  "summary": "Overall summary of the lecture"
}
```

### flashcards

Example structure:
```json
{
  "lecture_title": "Session 1 - The New Consumer",
  "model_used": "claude-3-haiku-20240307",
  "generated_at": "2025-11-24T10:10:00Z",
  "flashcards": [
    {
      "id": "fc_1",
      "front": "What is customer experience?",
      "back": "The sum of all interactions...",
      "tags": ["basics", "definitions"]
    }
  ],
  "total_count": 50
}
```

### quizzes

Flexible array format allowing multiple difficulty levels:
```json
[
  {
    "level": 1,
    "model_used": "gemini-2.0-flash-exp",
    "generated_at": "2025-11-24T10:15:00Z",
    "questions": [
      {
        "id": "q1_l1",
        "question": "What is the main topic?",
        "options": ["A", "B", "C", "D"],
        "correct_answer": "A",
        "explanation": "Because..."
      }
    ]
  },
  {
    "level": 2,
    "model_used": "gemini-2.0-flash-exp",
    "generated_at": "2025-11-24T10:15:00Z",
    "questions": [...]
  },
  {
    "level": 3,
    "questions": [...]
  },
  {
    "level": 4,
    "questions": [...]
  }
]
```

### error_log

Stores errors by pipeline step:
```json
{
  "analysis_error": {
    "error": "Connection timeout to Gemini API",
    "traceback": "Traceback (most recent call last):\n...",
    "timestamp": "2025-11-24T10:06:00Z"
  },
  "flashcard_error": {
    "error": "Rate limit exceeded",
    "traceback": "...",
    "timestamp": "2025-11-24T10:12:00Z"
  }
}
```

---

## SQL Schema Definition

```sql
-- courses table
CREATE TABLE courses (
    id SERIAL PRIMARY KEY,
    course_code VARCHAR(255) UNIQUE NOT NULL,
    course_name TEXT NOT NULL,
    instructor TEXT,
    additional_info TEXT,
    reference_textbooks JSONB DEFAULT '[]'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_courses_course_code ON courses(course_code);

-- lectures table
CREATE TABLE lectures (
    id SERIAL PRIMARY KEY,
    course_code VARCHAR(255) NOT NULL REFERENCES courses(course_code) ON DELETE CASCADE,
    lecture_title TEXT NOT NULL,
    r2_pdf_path TEXT NOT NULL,
    structured_analysis JSONB,
    flashcards JSONB,
    quizzes JSONB,
    analysis_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    flashcard_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    quiz_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    qdrant_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    error_log JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_lectures_course_code ON lectures(course_code);
CREATE INDEX idx_lecture_analysis_status ON lectures(analysis_status);
CREATE INDEX idx_lecture_flashcard_status ON lectures(flashcard_status);
CREATE INDEX idx_lecture_quiz_status ON lectures(quiz_status);
CREATE INDEX idx_lecture_qdrant_status ON lectures(qdrant_status);
```

---

## Migration Strategy

The tables are automatically created on first startup by SQLAlchemy using the models defined in `backend/app/models/content.py`.

To manually create the database:

```bash
# Connect to PostgreSQL
psql -U postgres

# Create database
CREATE DATABASE self_learning_ai;

# Grant permissions (if needed)
GRANT ALL PRIVILEGES ON DATABASE self_learning_ai TO your_user;
```

Then start the FastAPI application - tables will be created automatically.

---

## Querying Examples

### Find all pending lectures for analysis
```sql
SELECT id, course_code, lecture_title 
FROM lectures 
WHERE analysis_status = 'pending';
```

### Find all failed operations
```sql
SELECT id, course_code, lecture_title, 
       analysis_status, flashcard_status, quiz_status, qdrant_status,
       error_log
FROM lectures 
WHERE analysis_status = 'failed' 
   OR flashcard_status = 'failed' 
   OR quiz_status = 'failed' 
   OR qdrant_status = 'failed';
```

### Get course progress summary
```sql
SELECT 
    c.course_code,
    c.course_name,
    COUNT(l.id) as total_lectures,
    COUNT(CASE WHEN l.analysis_status = 'completed' THEN 1 END) as analysis_complete,
    COUNT(CASE WHEN l.flashcard_status = 'completed' THEN 1 END) as flashcard_complete,
    COUNT(CASE WHEN l.quiz_status = 'completed' THEN 1 END) as quiz_complete,
    COUNT(CASE WHEN l.qdrant_status = 'completed' THEN 1 END) as indexed_complete
FROM courses c
LEFT JOIN lectures l ON c.course_code = l.course_code
GROUP BY c.course_code, c.course_name;
```

### Query JSONB data
```sql
-- Get all flashcards for a lecture
SELECT flashcards->'flashcards' 
FROM lectures 
WHERE id = 1;

-- Get quiz questions for level 2
SELECT jsonb_array_elements(quizzes) 
FROM lectures 
WHERE id = 1 
AND jsonb_array_elements(quizzes)->>'level' = '2';

-- Find lectures with specific error type
SELECT id, course_code, lecture_title, error_log->'analysis_error'
FROM lectures
WHERE error_log ? 'analysis_error';
```

---

## Benefits of This Schema

1. **Normalized**: Course data separated from lecture data
2. **Flexible**: JSONB allows schema evolution without migrations
3. **Indexed**: Fast queries on status fields
4. **Auditable**: Timestamps track creation and updates
5. **Resilient**: Error logging per pipeline step
6. **Scalable**: Supports thousands of courses and lectures efficiently

